- content_for(:subheader) do
  .row.center.edit
    .col.pe-10
      .row
        .col
          %h2
            = link_to samples_reports_path, class: "side-link", title: "Back" do
              = image_tag "arrow-left.png"
            = @samples_report.name

.row
  .col
    .row
      .col.pe-4
        .samples-report
          .report-summary-content 
            .title
              Summary
            .subtitle 
              Samples
            .text 
              = @samples_report.samples_report_samples.length
              -if @samples_without_results_count > 0
                (#{@samples_without_results_count} without results)
            .subtitle 
              Box Purpose
            .text 
              = @samples_report.samples[0].box.purpose
            .separation 
            .action
              = link_to "", :onclick => "{downloadSvg('barchart', 'measured_signal');downloadSvg('linechart', 'LOD');}", id: "download-svg" do
                .subtitle 
                  = icon_tag "barchart", class: "btn-icon icon-text-color"
                  Download charts as svg
            .action
              =link_to print_samples_report_path, id: @samples_report.id, target: "_blank" do
                .subtitle{id:'print-as-pdf'}
                  = icon_tag "as-pdf", class: "btn-icon icon-text-color"
                  Download PDF

        - if @can_delete
          .report-summary-after
            =link_to delete_samples_report_path, id: @samples_report.id, data: { method: "delete", confirm: "You're about to permanently this box report. This action CANNOT be undone. Are you sure you want to proceed?" } do
              .subtitle
                = icon_tag "trash", class: "btn-icon icon-text-color"
                Delete Report
              
      .col
        .samples-report{id:'samples-report'}
          .report-content 
            .title
              Confusion Matrix
            .separation 
            = render 'confusion_matrix'
            .separation 
            .title
              Measured signal
            = react_component('BoxReportsBarChart', 
                        data: @reports_data, 
                        height: 300, 
                        barVariable: "average",
                        errorBarsVariable: "errors",
                        y_label: 'Measured Signal', 
                        x_labels: ["Virus"])

            - if @samples_report.samples[0].box.purpose == "LOD"
              .separation 
              .title
                Limit of detection
              = react_component('BoxReportsLineChart', 
                          data: @reports_data, 
                          height: 300, 
                          dotsVariable: "measurements",
                          y_label: 'Measured Signal', 
                          x_labels: [])

          // - if @samples_report.samples[0].box.purpose == "Challenge"
          //.separation 
          //.title
          //  ROC Curve
          //  = react_component('BoxReportsLineChart' <- TO DO

:javascript

  function applyInline(element, recursive = true) {
    if (!element) {
      throw new Error("No element specified.");
    }

    const matches = matchRules(element);

    // we need to preserve any pre-existing inline styles.
    var srcRules = document.createElement(element.tagName).style;
    srcRules.cssText = element.style.cssText;

    matches.forEach(rule => {
      for (var prop of rule.style) {

        let val = srcRules.getPropertyValue(prop) || rule.style.getPropertyValue(prop);
        let priority = rule.style.getPropertyPriority(prop);

        element.style.setProperty(prop,val,priority);
      }
    });

    if (recursive) {
      for (let item of element.children) {
          applyInline(item, recursive)
      }
    }
  }

  function matchRules(el, sheets) {
    sheets = sheets || document.styleSheets;
    var ret = [];

    for (var i in sheets) {
      if (sheets.hasOwnProperty(i)) {
        var rules = sheets[i].rules || sheets[i].cssRules;
        for (var r in rules) {
          if (el.matches(rules[r].selectorText)) {
            ret.push(rules[r]);
          }
        }
      }
    }
    return ret;
  }

  function downloadSvg(chartId, chartName) {
    var svgData = document.getElementById(chartId);
    applyInline(svgData);
    svgData = svgData.outerHTML;
    var svgBlob = new Blob([svgData], {type:"image/svg+xml;charset=utf-8"});
    var svgUrl = URL.createObjectURL(svgBlob);
    var downloadLink = document.createElement("a");
    downloadLink.href = svgUrl;
    downloadLink.download = `#{@samples_report.name}_${chartName}.svg`;
    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);
  }

